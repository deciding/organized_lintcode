LFU http://bookshadow.com/weblog/2016/11/22/leetcode-lfu-cache/ valueMap, nodeMap, double linked increasing freq node, linkedhashset keys with same freq
LRU nodeMap, double linked value node
catalan number: 2nCn/(n+1) C: 1*n/2*(n-1)/3....
Tower of Hanoi: odd even, format {} ABC, recursion, reverse
anagrams: calc hash of string
first unique char in string: hashmap -> charArr
segment tree, fenwick tree? 4n?
clone binary tree, binary tree sum -> path, bst -> double list
reorder arr -> largest number: prove as bubble sort
Triangle Count: how many combination of arr can form triangle, 3sum
Longest Substring with At Most K Distinct Characters: window
maximum gap: bin
priorityqueue(initsize,comparator)
generate parenthesis: just care about the l r diff
number of islands ii: new land cell as stream, use UF
**O(logn) bst successor: https://www.jiuzhang.com/solution/inorder-successor-in-bst/, set successor as root when go left until val found;right null-> successor;right nonnull, right->left...end
listnode swap pairs: recursion
find k closest elem in sorted arr: last smaller bs + left/right pointer
find k most freq word in arr: hashmap node, pq node with size k. another way https://www.geeksforgeeks.org/find-the-k-most-frequent-words-from-a-file/
merge k sorted arr: 1. binary merge 2. heap with all first elem inserted first
wiggle sort <=: just swap(easy actually), wiggle sort ii <: partition and find median(use absolute index), reverse arr(two pointer)
decodes way of int to ascii: if only need limited prev, no need arr. 4 cases 1.>2 0, return, 2. 0 cur=pp, 3. 1,2 <7 cur=p+pp, 4. cur=p
perfect squares: n*k but mem[n], with pruned k. xxxxx should think as 1d mem, but exaust all the square cases

paint fence: 2 cases
paint house: 3 colors, n*3; k colors, n*k, left right min 
robber ii circle(search 2 run), robber iii tree(use global, 4 mem ll/lr/rl/rr)
trapping rain: proof, visited, pq start from lowest surround, adj if smaller will get the h, assign new height, offer all adj
patching arr: proof, if num smaller than miss, miss + num will get new miss
move 0s to end: partition, no need swap, assign 0s at last
top k: k heap, quick select(partition)
zigzag iterator: i,j compare, if finished one arr, assign max to i/j
intersection of two arr: sort, merge
top k freq: kheap+map with (val,key) order
top k freq: no stream-> kheap+hashmap, stream(add()+topk()) -> double list + hashmap, freq node contains keys(linkedhashset) | treeset with cmp refer to hashmap (this form a value treemap) | not treemap(keyset is also orderedset, iterator)
linkedhashset as LRU:add remove iterator.next
LinkedHashSet use LinkedHashMap implemented by hashmap+double linked list
bomb enemy: W E 0, 4 accumulate matrix
bloom filter: multiple hash func, bits arr save tf/count
combination sum iv: num[] can be repeated, thus it cannot form a state
find the missing number ii: all numbers in str, dp not going to be useful, although we get non-tree graph, we need exact graph, not just a value of some state(but suffix may recompute, can separate by space and hash)
expression expansion 3[2[ad]3[pf]]xyz: stack, ] pop, number accumulate, reverse, stringbuilder
merge k sorted interval: 1. d&c, 2. heap https://www.jiuzhang.com/solution/merge-k-sorted-interval-lists/
merge intervals: keep start and end, read next 1. if i.start<=end, update end 2. else add (start,end), update start,end
word break ii, print but critical time limit: http://www.cnblogs.com/yuzhangcmu/p/4037299.html(suffix may recompute, can separate by space and hash, also can use boolean[] canbreak, but same as judge hashed string size)(also can precalculate canbreak boolean arr)
partition equal subset sum: since we know total sum <=60000, we can use dp on sum/2*n
strstrii: kmp
Smallest Rectangle Enclosing Black Pixels: we already know one pixel in black area, no need dfs to find bound, just use bs + range check (bs+bs will not work, since after mid, you may not in the black area)
bs can be used for 1111000000 pattern(not 011110000)
russian doll: sort->LIS, if same width cannot nested, reverse height order of same width
chuanzhitiao: 3 dim,same phase, weight deduction, 4->3 dim
1100010011011: remove adjacent(zuma), 2times, 3times
non overlap AB BA coexist(two side)
Largest Divisible Subset: max len, max len prev ind, max all len ind :https://www.geeksforgeeks.org/largest-divisible-subset-array/
sequence reconstruction: 1. adjmat(careful dup edge), indegree decrease 2. edge no violate, edge contains all http://www.cnblogs.com/grandyang/p/6032498.html
Two Sum III - Data structure design: O(1) add, O(n) find, careful repeat val
Binary Tree Longest Consecutive Sequence II: global,left,right: http://www.cnblogs.com/grandyang/p/6864398.html method1
course schedule: test cycle: indegree(queue 0 indegree)/(revertvisited+conflict) http://www.cnblogs.com/grandyang/p/4484571.html
course schedule ii : use indegree and record 
Maximum Average Subarray IIï¼š cannot think of O(N), use bs, max~min, use (accumulate sum - k*est mean) , record lowest acc sum, once (acc_sum_mean_diff>lowest_sum_mean_diff) we checked est_mean<=ans https://www.jiuzhang.com/solutions/maximum-average-subarray/
